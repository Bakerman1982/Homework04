[
  {
    "objectID": "Homework04.html",
    "href": "Homework04.html",
    "title": "ST558 - Homework #4",
    "section": "",
    "text": "require(httr)\nrequire(jsonlite)\nrequire(purrr)\nrequire(dplyr)\n\n\nTask 1: Conceptual Questions\n\n1. What is the purpose of the lapply() function? What is the equivalent purrr function?\nThe lapply() function is used to apply a function to each element of a list/vector and return a result. It is as an alternative, and sometimes quicker, method to writing out a function. The purr equivalent of lapply is ‘map()’.\n2. Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = \"kendall\") on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\nlapply(my_list, function(x) cor(x, method = \"kendall\"))\n\n3. What are two advantages of using purrr functions instead of the BaseR apply family?\nDrawing answers from the Hadley Stack Overflow post, two advantages of using purrr over the *apply family of functions include:\n\nShorthand writing, a more concise method of writing code for what you want. map() produces the exact output as apply() but with fewer characters and fewer functional arguments. For example:\n\n\n#apply(mtcars, 2, mean)\napp &lt;- nchar(\"apply(mtcars, 2, mean)\")\n\n#map_dbl(mtcars, mean)\nmap &lt;- nchar(\"map_dbl(mtcars, mean)\")\n\ndata.frame(cbind(app, map))\n\n  app map\n1  22  21\n\n\n\nPurrr function variants. There are many but the walk() variant seems very useful for situations where we would be disinterested in data output but still want to perform that action invisibly. An example of this would be wanting to write many dataframes to a delimited file while assuming we are using tidyverse piping in a function. Ordinarily, we would call return(); however, since we are not concerned with the output but rather the action to be performed–the action of writing being the side-effect of calling walk()–walk() would serve to bridge the gap of piping in the tidyverse and writing to disk without showing the returned frames.\n\n4. What is a side-effect function?\nA side-effect function is a programming function that performs an action invisibly by not returning the original data value. Its common usages include writing data to disk and plotting data without a return.\n5. Why can you name a variable sd in a function and not cause any issues with the sd function?\nWhen a function contains a name for a variable, in this case sd as a var, and that function is called it does not store the name of that variable in the global environment. Instead, it is stored in a temporary environment that is called during the running of that function and then it is forgotten.\n\n\nTask 2 - Writing R Functions\n\n1. When we start doing machine learning later in the course, a common metric used to evaluate predictions is called Root Mean Square Error (RMSE).\nFor a given set of responses, \\(y1,...,yn\\) (variable of interest that we want to predict) and a set of corresponding predictions for those observations, \\(\\hat{y_1},..., \\hat{y_n}\\) the RMSE is defined as:\n\\[\\begin{gather*}RMSE = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{y_i})^2}\n\\end{gather*}\\]\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE. If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.\n\nSince we want a set of \\(y_n\\) and a corresponding set of \\(\\hat{y}_n\\), we need a check to see that the length of each response and predictor is equal. In my function, I included a call to stop() in the event that predictor and response were not corresponding. The second part of the function is the formula for RMSE.\n\ngetRMSE &lt;- function(responses, predictions, ...) {\n  #Formulation for RMSE with a call to return.  Includes ... argument to pass an NA check.\n  rmse &lt;- sqrt(mean((responses - predictions)^2, ...)) # ... = na.rm = TRUE to strip NA from responses vector\n  return(rmse)\n}\n\n2. Run the following code to create some response values and predictions.\nI changed the default input arguments from the homework pdf to match environment variables in my getRMSE function.\n\nset.seed(10)\n n &lt;- 100\n x &lt;- runif(n)\n responses &lt;- 3 + 10*x + rnorm(n)\n predictions &lt;- predict(lm(responses ~ x), data.frame(x))\n\n• Test your RMSE function using this data.\n\n\n#Call the function with the appropriate arguments\ngetRMSE(responses, predictions)\n\n[1] 0.9581677\n\n\n• Repeat after replacing two of the response values with missing values (NA_real_).\n\n#Manufacture case where two values are NA.  Second query checks that the NA call flowed through. \nresponses[32:33] = NA\nsum(is.na(responses))\n\n[1] 2\n\n\n– Test your RMSE function with and without specifying the behavior to deal with missing values.\n\n#Call the function with the appropriate arguments without additional arg -&gt; na.rm = TRUE\ngetRMSE(responses, predictions)\n\n[1] NA\n\n#Call the function with the appropriate arguments with additional arg -&gt; na.rm = TRUE\ngetRMSE(responses, predictions, na.rm = TRUE)\n\n[1] 0.9645526\n\n\n3. Another common metric for evaluating predictions is mean absolute deviation given by:\n\\[\\begin{gather*}MAE = \\frac{1}{n}\\sum_{i=1}^{n}|y_i-\\hat{y_i}|\n\\end{gather*}\\]\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\n\ngetMAE &lt;- function(responses, predictions, ...) {\n  #Formulation for MAE with a call to return.  Includes ... argument to pass an NA check.\n  mae &lt;- sqrt(mean(abs(responses - predictions), ...)) # ... = na.rm = TRUE to strip NA from responses vector\n  return(mae)\n}\n\n4. Run the following code to create some response values and predictions.\nI changed the default input arguments from the homework pdf to match environment variables in my getRMSE function.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresponses &lt;- 3 + 10*x + rnorm(n)\npredictions &lt;- predict(lm(responses ~ x), data.frame(x))\n\n• Test your MAE function using this data.\n\n\n#Call the function with the appropriate arguments\ngetMAE(responses, predictions)\n\n[1] 0.9030933\n\n\n• Repeat after replacing two of the response values with missing values (NA_real_).\n\n\n#Manufacture case where two values are NA.  Second query checks that the NA call flowed through. \nresponses[79:80] = NA\nsum(is.na(responses))\n\n[1] 2\n\n\n– Test your MAE function with and without specifying the behavior to deal with missing values.\n\n\n#Call the function with the appropriate arguments without additional arg -&gt; na.rm = TRUE\ngetMAE(responses, predictions)\n\n[1] NA\n\n#Call the function with the appropriate arguments with additional arg -&gt; na.rm = TRUE\ngetMAE(responses, predictions, na.rm = TRUE)\n\n[1] 0.9039635\n\n\n5. Let’s create a wrapper function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names.\n• The function should check that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, a message should print and the function should exit.\n• The function should return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.\nMy wrapper function is going to follow the same input arguments as the getRMSE and getMAE functions with the addition of a argument called “metrics”. This argument can accept RMSE or MAE, or it can completely ignored in which case my code will return output from both functions. The ellipses argument exists to accept the na.rm argument to reconcile scenarios where there are NA values in the response vector\n\ngetMetrics &lt;- function(responses, predictions, metrics = c(\"RMSE\", \"MAE\"), ...) {\n  # Check if inputs are numeric and vectors\n  if (!is.vector(responses) || !is.numeric(responses)) {\n    stop(\"responses must be a numeric vector\")\n  }\n  if (!is.vector(predictions) || !is.numeric(predictions)) {\n    stop(\"predictions must be a numeric vector\")\n  }\n  \n  # Initialize an empty list to store results\n  results &lt;- list()\n  \n  # Check if RMSE is requested\n  if (\"RMSE\" %in% metrics) {\n    results$RMSE &lt;- getRMSE(responses, predictions, ...)\n  }\n  \n  # Check if MAE is requested\n  if (\"MAE\" %in% metrics) {\n    results$MAE &lt;- getMAE(responses, predictions, ...)\n  }\n  \n  # Return the results list\n  return(results)\n}\n\n6. Run the following code to create some response values and predictions.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresponses &lt;- 3 + 10*x + rnorm(n)\npredictions &lt;- predict(lm(responses ~ x), data.frame(x))\n\n• Test your new function using this data. Call it once asking for each metric individually and once specifying both metrics\n\n\n#RMSE only\ngetMetrics(responses, predictions, \"RMSE\")\n\n$RMSE\n[1] 0.9581677\n\n#MAE only\ngetMetrics(responses, predictions, \"MAE\")\n\n$MAE\n[1] 0.9030933\n\n#Both, by not calling on the metric argument.  \ngetMetrics(responses, predictions)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.9030933\n\n\n• Repeat with replacing two of the response values with missing values (NA_real_).\n\n\n#Manufacture case where two values are NA.  Second query checks that the NA call flowed through. \nresponses[2:3] = NA\nsum(is.na(responses))\n\n[1] 2\n\n\n• Finally, test your function by passing it incorrect data (i.e. a data frame or something else instead of vectors)\n\n\n#This forces a response and prediction vector into a data.frame giving it a new object. \nresponses_df &lt;- as.data.frame(responses)\npredictions_df &lt;- as.data.frame(predictions)\n\n\n#The dataframe are called to the function arguments correctly forcing an error.  \ngetMetrics(responses_df, predictions_df)\n\nError in getMetrics(responses_df, predictions_df): responses must be a numeric vector\n\n\n\n\nTask 3- Querying an API and a Tidy-Style Function\nFor this section, you’ll connect to the news API here: newsapi.org. You’ll need to go to register for a key at that web site!\n1. Use GET() from the httr package to return information about a topic that you are interested in that has been in the news lately (store the result as an R object). Note: We can only look 30 days into the past with a free account.\nFirst I set several objects in my environment. The api_key was given to me from the NewsAPI website after signing up with an account. I choose NVIDIA due to their rising stock prices the last two quarters. For the date, I used Sys.Date to collect todays date and subtract 30 from it. The licensing agreement only allows for a 30 day lookback and figured something like that should be dynamic. I found a paste-URL format for creating a URL from a simple Google search. I would call the GET() function and place all the objects relevant inside as arguments.\n\n#Set up objects\napi_key &lt;- 'f0f1d686cc0b480c9d1e33dd5c150e25'\ntopic &lt;- \"ClimateChange\"\nfrom_date &lt;- Sys.Date() - 30\nurl &lt;- paste0(\"https://newsapi.org/v2/everything?q=\", topic, \"&from=\", from_date, \"&sortBy=publishedAt&apiKey=\", api_key)\n\nGet_URL_Response &lt;- httr::GET(url)\n\n# Notes to self: JSON format appears when \"url\", Get_URL_Repsonse is called.\n\n# extra helper code for quick checks\n# str(response, max.level=1)\n\n2. Parse what is returned and find your way to the data frame that has the actual article information in it (check content). Note the first column should be a list column!\n\n#Parse data using content()\nResponseContentParsed &lt;- content(Get_URL_Response,\"parsed\")\n#Called on articles from the parse data and assigned it an object to work with it easier. \narticles &lt;- ResponseContentParsed$articles\n\n\n#Had some issues here.  I kept receiving error message: \n\n#Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE,  : \n#arguments imply differing number of rows: 0, 1\n\n#Google Searched my way through the problem--somewhat.  I retrieved some of these queries to help get the answer I wanted.  \n\n# Check lengths and filter out empty elements\nlengths &lt;- sapply(articles, length)\nnon_empty_articles &lt;- articles[lengths &gt; 0]\n\n# Convert non-empty elements to data frames\ndf_list &lt;- lapply(non_empty_articles, function(x) {\n  tryCatch(\n    as.data.frame(x, stringsAsFactors = FALSE),\n    error = function(e) NULL\n  )\n})\n\n# Filter out NULL elements resulting from errors\ndf_list &lt;- Filter(function(x) !is.null(x), df_list)\n\n# Inspect the resulting list of data frames\nstr(df_list)\n\n list()\n\n\n3. Now write a quick function that allows the user to easily query this API. The inputs to the function should be the title/subject to search for (string), a time period to search from (string- you’ll search from that time until the present), and an API key. Use your function twice!\n\nlibrary(httr)\n\nAPI_call &lt;- function(title, time, api_key) {\n  # Root URL to base the website from.\n  rootURL &lt;- \"https://newsapi.org/v2/everything\"\n  \n  # Convert time to string in the required format\n  time_str &lt;- format(time, \"%Y-%m-%d\")\n  \n  # URL input \n  URL_elements &lt;- list(\n    q = title,\n    from = time_str,\n    apiKey = api_key\n  )\n  \n  # Create the URL\n  response &lt;- GET(url = rootURL, query = URL_elements)\n  \n  # Check if request was successful (status code 200)\n  if (http_status(response)$status == 200) {\n    # Parse the JSON response\n    data &lt;- content(response, \"parsed\")\n    return(data)\n  } else {\n    # If request failed, print error message\n    stop(paste(\"HTTP error:\", http_status(response)$reason))\n  }\n}\n\n# Example usage\nAPI_call(\"Lisinopril\", as.Date(\"2024-06-25\"), \"f0f1d686cc0b480c9d1e33dd5c150e25\")\n\nError in if (http_status(response)$status == 200) {: argument is of length zero\n\nAPI_call(\"Ozempic\", as.Date(\"2024-06-25\"), \"f0f1d686cc0b480c9d1e33dd5c150e25\")\n\nError in if (http_status(response)$status == 200) {: argument is of length zero"
  }
]